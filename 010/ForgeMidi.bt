#include "common.bt"

LittleEndian();

// Forge MIDI
typedef enum <uchar> {
    NOTE_OFF = 0x8,
    NOTE_ON  = 0x9,
    POLY_PRS = 0xA,
    CTRL_CHG = 0xB,
    PRGM_CHG = 0xC,
    CHAN_PRS = 0xD,
    PITCH_BD = 0xE
} msg_type;

typedef struct {
    char channel : 4;
    msg_type type : 4;
} msg_type_chan;

typedef int tick_t<read=tick_t_read>;
string tick_t_read(tick_t tick){
    string result;
    SPrintf(result, "%d:%d", tick / 480, tick % 480);
    return result;
}

typedef struct {
    char note;
    char velocity;
} M_NOTE_ON;

typedef struct {
    char note;
    char velocity;
} M_NOTE_OFF;

typedef struct {
    char unk[2];
} M_POLY_PRS;

typedef struct {
    char controller;
    char amt;
} M_CTRL_CHG;

typedef struct {
    char unk[2];
} M_PRGM_CHG;

typedef struct {
    char unk[2];
} M_CHAN_PRS;
typedef struct {
    char lsb;
    char msb;
} M_PITCH_BD;

typedef unsigned char int24[3]<read=int24_read>;
string int24_read(int24 v)
{
    int val = ((int)v[0] << 16) | ((int)v[2] << 8) | v[1];
    string ret;
    SPrintf(ret, "%d", val);
    return ret;
}

typedef struct {
    uint tick;
    char kind;
    if(kind == 1){
        msg_type_chan tc;
        if(tc.type > 9){
            Printf("Type %d\n", tc.type);
        }
        switch(tc.type){
            case NOTE_OFF:
                M_NOTE_OFF msg;
                break;
            case NOTE_ON:
                M_NOTE_ON msg;
                break;
            case POLY_PRS:
                M_POLY_PRS msg;
                break;
            case CTRL_CHG:
                M_CTRL_CHG msg;
                break;
            case PRGM_CHG:
                M_PRGM_CHG msg;
                break;
            case CHAN_PRS:
                M_CHAN_PRS msg;
                break;
            case PITCH_BD:
                M_PITCH_BD msg;
                break;
        }
    }
    else if(kind == 2) {
		// weird: MSB first, then remaining bytes in LE
        int24 tempo;
    }
    else if(kind == 4) {
        char num;
        char denom;
        char unused;
    }
    else if(kind == 8) {
        // I think this is 1 -> text event, 3 -> track name, 5 -> lyric
        char string_type;
        int16 string_offset;
    }
    else {
        local string tmp;
        SPrintf(tmp, "Unknown kind %d", kind);
        Assert(false, tmp);
    }
} midi_message<optimize=false>;

typedef struct {
    uint tick;
    PSTR lyric;
} LYRIC<read=LYRIC_READ,optimize=false>;
string LYRIC_READ(LYRIC& l){
    return PSTR_READ(l.lyric);
}

typedef struct {
    PSTR track_name;
    int num_events;
    if(num_events > 0)
        LYRIC lyrics[num_events];
    int unknown;
    int unknown_2;
    char unk;
} LYRICS<read=LYRICS_READ,optimize=false>;
string LYRICS_READ(LYRICS& t){
    return PSTR_READ(t.track_name);
}

typedef struct {
    int num_fills_1;
    if(num_fills_1 > 0)
        struct {
            int tick;
            int unk;
        } fills_1[num_fills_1];
    int num_fills_2;
    if(num_fills_2 > 0)
        struct {
            int fill_start_tick;
            int fill_end_tick;
            char unk;
        } fill_start_stop[num_fills_2];
} DRUMFILL;

typedef struct {
    PSTR track_name;
    int unk;
    int unk;
    int num_events;
    struct {
        float time;
        tick_t ticks;
        int unk1;
        // Stores each key down as (1 << (MIDI_NOTE - 48))
        int key_bitfield<read=READ_KEY_POS>;
        int unk2;
        short unk3;
    } events[num_events];
    int unk;
} ANIM;
string READ_KEY_POS(int k)
{
    int bit = (int)(Log(k)/Log(2.0));
    string ret;
    SPrintf(ret, "%d", bit);
    return ret;
}

typedef struct {
    int num_pro_markers;
    struct {
        tick_t tick;
        struct {
            int unk : 1;
            int unk2: 1;
            int PRO_YELLOW : 1;
            int PRO_BLUE : 1;
            int PRO_GREEN : 1;
        } flags;
    } markers[num_pro_markers];
    int unk;
    int unk;
} MARKER;

typedef struct {
    int num;
    if(num > 0){
        struct {
            int32 data;
            if(data > 0){
                int32 data2;
                int32 data3;
            }
        } data2[num]<optimize=false>;
        int unk;
    }    
} UNKTRACK;

typedef struct {
    int num;
    if(num > 0)
        struct{
            int count;
            struct {
                int tick1;
                int tick2;
                int unk1;
                int unk2;
            } unk[count];
        } data[num]<optimize=false>;
} UNKTRACK2;

typedef struct {
    int num_difficulties;
    struct {
        int num_mixes;
        if(num_mixes)
            LYRIC mix[num_mixes];
    } drum_mixes[num_difficulties]<optimize=false>;
} DRUMMIX;

typedef struct {
    int num_difficulties;
    struct {
        int unknown_aa;
        int num_events;
        if(num_events)
            struct {
                float start_millis;
                int start_ticks;
                short unk;
                short unk_2;
                char one_1;
                int unk_3;
                char one_2;
                int unk_4;
            } gem[num_events];
    } difficulty[num_difficulties]<optimize=false>;
    int end;
} GEMTRACK;

typedef struct {
    int num_difficulties;
    struct {
        int num_events;
        struct {
            int num_events_2;
            struct { 
                int tick_1;
                int tick_2; 
            } what[num_events_2]<optimize=false>;
        } events[num_events]<optimize=false>;
    } again[num_difficulties]<optimize=false>;
} UNKTRACK3;

typedef struct {
    int num_phrase_markers;
    struct {
        float start_ms;
        float length;
        int unk;
        int unk;
        int unk;
        int unk;
        int unk;
        char unknown[25];
    } phrase_markers[num_phrase_markers] <optimize=false>;
    int num_phrase_markers_2;
    struct {
        float start_ms;
        float length;
        int unk;
        int unk;
        int unk;
        int unk;
        int unk;
        char unknown[25];
    } phrase_markers_2[num_phrase_markers_2] <optimize=false>;
    int num_notes;
    struct {
        int type;
        int midi_note;
        int midi_note_2;
        float start_ms;
        tick_t start;
        float length;
        short unk1;
        PSTR lyric;
        char unk[9];
    } vocal_notes[num_notes]<optimize=false>;
    int num_something;
    int something[num_something];
    int num_unk2;
    struct {
        float data;
        float data2;
    }unk2[num_unk2];
} VOCALTRACK;

typedef struct {
    int num_maps;
    struct {
        float start_ms;
        int map;
    } hand_maps[num_maps];
} HANDMAP;

typedef struct {
    int num_hand_positions;
    struct {
        float start;
        float end;
        int position;
        char unk;
    } hand_pos_events[num_hand_positions];
} HANDPOS;

typedef struct {
    int count;
    float data[count];
} UNKTRACK4;

typedef struct {
    char unk;
    int unk2;
    int num_events;
    midi_message events[num_events];
    int num_strs;
    PSTR strings[num_strs]<optimize=false>;
} MIDITRACK;

typedef int tempo_t<read=tempo_t_read>;
string tempo_t_read(tempo_t tempo){
    string result;
    SPrintf(result, "%f", 60000000.0 / tempo);
    return result;
}
typedef struct {
    float time;
    tick_t tick;
    tempo_t tempo;
} TEMPO;

typedef struct {
    int unk;
    int tick;
    int16 numerator;
    int16 denominator;
} TIMESIG<read=TIMESIG_read>;
string TIMESIG_read(TIMESIG& t){
    string ret;
    SPrintf(ret, "%d : %d/%d", t.tick, t.numerator, t.denominator);
    return ret;
}

typedef struct {
    tick_t tick;
    int is_downbeat;
} BEAT;
// File starts here!

int format;
if(format == 0x10 || format == 0x2f){ // rbmid_ps4/pc
    int num_lyric_tracks;
    LYRICS lyrics[num_lyric_tracks] <optimize=false>;
    int num_fill_tracks;
    DRUMFILL drum_fills[num_fill_tracks] <optimize=false>;
    int num_anim_tracks;
    ANIM anims[num_anim_tracks] <optimize=false>;
    int num_marker_tracks;
    MARKER pro_markers[num_marker_tracks] <optimize=false>;
    int num_unk_tracks;
    UNKTRACK unk_1[num_unk_tracks] <optimize=false>;
    int num_unk_tracks_2;
    UNKTRACK2 unk_2[num_unk_tracks_2] <optimize=false>;
    int num_drum_mixes;
    DRUMMIX drum_mixes[num_drum_mixes] <optimize=false>;
    int num_gem_tracks;
    GEMTRACK gems[num_gem_tracks] <optimize=false>;
    int num_unk_tracks_3;
    UNKTRACK3 unk_3[num_unk_tracks_3] <optimize=false>;
    int num_vocal_tracks;
    VOCALTRACK vocal_tracks[num_vocal_tracks]<optimize=false>;
    int what;
    int what;
    float what;
    int what;
    int what;
    int what;
    int what;
    float what;
    float what;
    int what;
    int what;
    int what;
    char what;
    float what;
    float what;
    int num_guitar_handmap_tracks;
    HANDMAP guitar_handmap_tracks[num_guitar_handmap_tracks]<optimize=false>;
    int num_left_hand_tracks;
    HANDPOS left_hand_tracks[num_left_hand_tracks]<optimize=false>;
    int num_unk_tracks_4;
    UNKTRACK4 unk_4[num_unk_tracks_4]<optimize=false>;
    int num_unk;
    struct {
        tick_t start;
        tick_t end;
        int unk;
    } unk[num_unk];
    int zero;
    struct {
        int num_unk_markup;
        struct {
            tick_t start;
            tick_t end;
            int count;
            int unk[count];
        } unk_markup[num_unk_markup]<optimize=false>;
    } unk_markup;
    int zero;
    int count;
    struct {
        tick_t start;
        tick_t end;
        int unk;
    } unk2[count];
    int zero;
    int two;
    int unk;
    int num_midi_tracks;
    MIDITRACK tracks[num_midi_tracks]<optimize=false>;
    int unknown[13];
    int num_tempos;
    TEMPO tempos[num_tempos];
    int num_time_sigs;
    TIMESIG time_signatures[num_time_sigs];
    int num_beats;
    BEAT beats[num_beats];
    int unk_zero;
    int num_midi_track_names;
    PSTR midi_track_names[num_midi_track_names]<optimize=false>;

    // File End
}
else if(format == 0x2){ // mid_ps4/pc
    char header[29];
    PSTR seq_name;
    char unk;
    int unk2;
    int num_msgs;
    int unk3;
    int unk4;
    midi_message msgs[num_msgs];
}