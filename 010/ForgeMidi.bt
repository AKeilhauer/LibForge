#include "common.bt"

LittleEndian();

// Forge MIDI
typedef enum <uchar> {
    NOTE_OFF = 0x80,
    NOTE_ON  = 0x90,
    POLY_PRS = 0xA0,
    CTRL_CHG = 0xB0,
    PRGM_CHG = 0xC0,
    CHAN_PRS = 0xD0,
    PITCH_BD = 0xE0
} msg_type;

typedef struct {
    char note;
    char velocity;
} M_NOTE_ON;

typedef struct {
    char note;
    char velocity;
} M_NOTE_OFF;

typedef struct {
    char unk[2];
} M_POLY_PRS;

typedef struct {
    char controller;
    char amt;
} M_CTRL_CHG;

typedef struct {
    char unk[2];
} M_PRGM_CHG;

typedef struct {
    char unk[2];
} M_CHAN_PRS;
typedef struct {
    char lsb;
    char msb;
} M_PITCH_BD;

typedef struct {
    uint tick;
    char channel;
    msg_type type;
    switch(type){
        case NOTE_OFF:
            M_NOTE_OFF msg;
            break;
        case NOTE_ON:
            M_NOTE_ON msg;
            break;
        case POLY_PRS:
            M_POLY_PRS msg;
            break;
        case CTRL_CHG:
            M_CTRL_CHG msg;
            break;
        case PRGM_CHG:
            M_PRGM_CHG msg;
            break;
        case CHAN_PRS:
            M_CHAN_PRS msg;
            break;
        case PITCH_BD:
            M_PITCH_BD msg;
            break;
    }
} midi_message<optimize=false>;

typedef struct {
    uint tick;
    PSTR lyric;
} LYRIC<read=LYRIC_READ,optimize=false>;
string LYRIC_READ(LYRIC& l){
    return PSTR_READ(l.lyric);
}

typedef struct {
    PSTR track_name;
    int num_events;
    if(num_events > 0)
        LYRIC lyrics[num_events];
    int unknown;
    int unknown_2;
    char unk;
} LYRICS<read=LYRICS_READ,optimize=false>;
string LYRICS_READ(LYRICS& t){
    return PSTR_READ(t.track_name);
}

typedef struct {
    int num_fills_1;
    if(num_fills_1 > 0)
        struct {
            int tick;
            int unk;
        } fills_1[num_fills_1];
    int num_fills_2;
    if(num_fills_2 > 0)
        struct {
            int fill_start_tick;
            int fill_end_tick;
            char unk;
        } fill_start_stop[num_fills_2];
} DRUMFILL;

typedef struct {
    PSTR track_name;
    int unk;
    int unk;
    int num_events;
    struct {
        char unk_event_data[22];
    } events[num_events];
    int unk;
} ANIM;

typedef struct {
    int num_pro_markers;
    struct {
        int tick;
        struct {
            int unk : 1;
            int unk2: 1;
            int PRO_YELLOW : 1;
            int PRO_BLUE : 1;
            int PRO_GREEN : 1;
        } flags;
    } markers[num_pro_markers];
    int unk;
    int unk;
} MARKER;

typedef struct {
    int num_difficulties;
    struct {
        int num_mixes;
        if(num_mixes)
            LYRIC mix[num_mixes];
    } drum_mixes[num_difficulties]<optimize=false>;
} DRUMMIX;

typedef struct {
    int num_difficulties;
    struct {
        int unknown_aa;
        int num_events;
        if(num_events)
            struct {
                float start_millis;
                int start_ticks;
                short unk;
                short unk_2;
                char one_1;
                int unk_3;
                char one_2;
                int unk_4;
            } gem[num_events];
    } difficulty[num_difficulties]<optimize=false>;
    int end;
} GEMTRACK;

typedef struct {
    int num;
    if(num > 0)
        int data[num];
} UNKTRACK4;

// File starts here!

int format;
if(format == 0x10 || format == 0x2f){ // rbmid_ps4/pc
    int num_lyric_tracks;
    LYRICS lyrics[num_lyric_tracks] <optimize=false>;
    int num_fill_tracks;
    DRUMFILL drum_fills[num_fill_tracks] <optimize=false>;
    int num_anim_tracks;
    ANIM anims[num_anim_tracks] <optimize=false>;
    int num_marker_tracks;
    MARKER pro_markers[num_marker_tracks] <optimize=false>;
    int num_unk_tracks;
    UNKTRACK4 unk_1[num_unk_tracks] <optimize=false>;
    int num_unk_tracks_2;
    UNKTRACK4 unk_2[num_unk_tracks_2] <optimize=false>;
    int num_drum_mixes;
    DRUMMIX drum_mixes[num_drum_mixes] <optimize=false>;
    int num_gem_tracks;
    GEMTRACK gems[num_gem_tracks] <optimize=false>;
    int num_tracks_again;
    int num_difficulties;
}
else if(format == 0x2){ // mid_ps4/pc
    char header[29];
    PSTR seq_name;
    char unk;
    int unk2;
    int num_msgs;
    int unk3;
    int unk4;
    midi_message msgs[num_msgs];
    
}